// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/rust.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class RustBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
  _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  RustBindings(ffi.DynamicLibrary dynamicLibrary)
    : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  RustBindings.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  ffi.Pointer<ffi.Void> renderer() {
    return _renderer();
  }

  late final _rendererPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>('renderer');
  late final _renderer = _rendererPtr
      .asFunction<ffi.Pointer<ffi.Void> Function()>();

  void register_font_family(
    ffi.Pointer<ffi.Void> renderer,
    ffi.Pointer<ffi.Char> family,
    int family_len,
    ffi.Pointer<ffi.Char> data,
    int len,
  ) {
    return _register_font_family(renderer, family, family_len, data, len);
  }

  late final _register_font_familyPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Char>,
            ffi.Size,
            ffi.Pointer<ffi.Char>,
            ffi.Size,
          )
        >
      >('register_font_family');
  late final _register_font_family = _register_font_familyPtr
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>,
          int,
        )
      >();

  void register_style(
    ffi.Pointer<ffi.Void> renderer,
    Style style,
    ffi.Pointer<TextStyle> textStyle,
  ) {
    return _register_style(renderer, style.value, textStyle);
  }

  late final _register_stylePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ffi.UnsignedInt,
            ffi.Pointer<TextStyle>,
          )
        >
      >('register_style');
  late final _register_style = _register_stylePtr
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<TextStyle>)
      >();

  ffi.Pointer<ffi.Void> layout(
    ffi.Pointer<ffi.Void> renderer,
    ffi.Pointer<ffi.Char> usfm,
    int len,
    ffi.Pointer<Dimensions> dim,
  ) {
    return _layout(renderer, usfm, len, dim);
  }

  late final _layoutPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Char>,
            ffi.Size,
            ffi.Pointer<Dimensions>,
          )
        >
      >('layout');
  late final _layout = _layoutPtr
      .asFunction<
        ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<Dimensions>,
        )
      >();

  void page(
    ffi.Pointer<ffi.Void> layout,
    ffi.Pointer<ffi.Pointer<Text>> out,
    ffi.Pointer<ffi.Size> out_len,
  ) {
    return _page(layout, out, out_len);
  }

  late final _pagePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Pointer<Text>>,
            ffi.Pointer<ffi.Size>,
          )
        >
      >('page');
  late final _page = _pagePtr
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Pointer<Text>>,
          ffi.Pointer<ffi.Size>,
        )
      >();
}

final class TextStyle extends ffi.Struct {
  external ffi.Pointer<ffi.Char> font_family;

  @ffi.Size()
  external int font_family_len;

  @ffi.Float()
  external double font_size;

  @ffi.Float()
  external double height;

  @ffi.Float()
  external double letter_spacing;

  @ffi.Float()
  external double word_spacing;
}

enum Style {
  VERSE(0),
  NORMAL(1),
  HEADER(2),
  CHAPTER(3);

  final int value;
  const Style(this.value);

  static Style fromValue(int value) => switch (value) {
    0 => VERSE,
    1 => NORMAL,
    2 => HEADER,
    3 => CHAPTER,
    _ => throw ArgumentError("Unknown value for Style: $value"),
  };
}

final class Rectangle extends ffi.Struct {
  @ffi.Float()
  external double top;

  @ffi.Float()
  external double left;

  @ffi.Float()
  external double width;

  @ffi.Float()
  external double height;
}

final class Text extends ffi.Struct {
  external ffi.Pointer<ffi.Char> text;

  @ffi.Size()
  external int len;

  external Rectangle rect;

  external TextStyle style;
}

final class Dimensions extends ffi.Struct {
  @ffi.Float()
  external double width;

  @ffi.Float()
  external double height;

  @ffi.Float()
  external double header_height;

  @ffi.Float()
  external double header_padding;
}
