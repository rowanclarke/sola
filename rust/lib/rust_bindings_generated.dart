// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/rust.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class RustBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
  _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  RustBindings(ffi.DynamicLibrary dynamicLibrary)
    : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  RustBindings.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  ffi.Pointer<ffi.Void> renderer() {
    return _renderer();
  }

  late final _rendererPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>('renderer');
  late final _renderer = _rendererPtr
      .asFunction<ffi.Pointer<ffi.Void> Function()>();

  void register_font_family(
    ffi.Pointer<ffi.Void> renderer,
    ffi.Pointer<ffi.Char> family,
    int family_len,
    ffi.Pointer<ffi.Char> data,
    int len,
  ) {
    return _register_font_family(renderer, family, family_len, data, len);
  }

  late final _register_font_familyPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Char>,
            ffi.Size,
            ffi.Pointer<ffi.Char>,
            ffi.Size,
          )
        >
      >('register_font_family');
  late final _register_font_family = _register_font_familyPtr
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>,
          int,
        )
      >();

  void register_style(
    ffi.Pointer<ffi.Void> renderer,
    Style style,
    ffi.Pointer<TextStyle> textStyle,
  ) {
    return _register_style(renderer, style.value, textStyle);
  }

  late final _register_stylePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ffi.UnsignedInt,
            ffi.Pointer<TextStyle>,
          )
        >
      >('register_style');
  late final _register_style = _register_stylePtr
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<TextStyle>)
      >();

  ffi.Pointer<ffi.Void> layout(
    ffi.Pointer<ffi.Void> renderer,
    ffi.Pointer<ffi.Char> usfm,
    int len,
    ffi.Pointer<Dimensions> dim,
  ) {
    return _layout(renderer, usfm, len, dim);
  }

  late final _layoutPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Char>,
            ffi.Size,
            ffi.Pointer<Dimensions>,
          )
        >
      >('layout');
  late final _layout = _layoutPtr
      .asFunction<
        ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<Dimensions>,
        )
      >();

  void serialize_pages(
    ffi.Pointer<ffi.Void> layout,
    ffi.Pointer<ffi.Pointer<ffi.Char>> out,
    ffi.Pointer<ffi.Size> out_len,
  ) {
    return _serialize_pages(layout, out, out_len);
  }

  late final _serialize_pagesPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Pointer<ffi.Char>>,
            ffi.Pointer<ffi.Size>,
          )
        >
      >('serialize_pages');
  late final _serialize_pages = _serialize_pagesPtr
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
        )
      >();

  ffi.Pointer<ffi.Void> archived_pages(
    ffi.Pointer<ffi.Char> pages,
    int pages_len,
  ) {
    return _archived_pages(pages, pages_len);
  }

  late final _archived_pagesPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>, ffi.Size)
        >
      >('archived_pages');
  late final _archived_pages = _archived_pagesPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>, int)>();

  int num_pages(ffi.Pointer<ffi.Void> archived_pages) {
    return _num_pages(archived_pages);
  }

  late final _num_pagesPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Void>)>>(
        'num_pages',
      );
  late final _num_pages = _num_pagesPtr
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  void page(
    ffi.Pointer<ffi.Void> renderer,
    ffi.Pointer<ffi.Void> archived_pages,
    int n,
    ffi.Pointer<ffi.Pointer<Text>> out,
    ffi.Pointer<ffi.Size> out_len,
  ) {
    return _page(renderer, archived_pages, n, out, out_len);
  }

  late final _pagePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Size,
            ffi.Pointer<ffi.Pointer<Text>>,
            ffi.Pointer<ffi.Size>,
          )
        >
      >('page');
  late final _page = _pagePtr
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Pointer<Text>>,
          ffi.Pointer<ffi.Size>,
        )
      >();

  void serialize_indices(
    ffi.Pointer<ffi.Void> painter,
    ffi.Pointer<ffi.Pointer<ffi.Char>> out,
    ffi.Pointer<ffi.Size> out_len,
  ) {
    return _serialize_indices(painter, out, out_len);
  }

  late final _serialize_indicesPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Pointer<ffi.Char>>,
            ffi.Pointer<ffi.Size>,
          )
        >
      >('serialize_indices');
  late final _serialize_indices = _serialize_indicesPtr
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
        )
      >();

  ffi.Pointer<ffi.Void> archived_indices(
    ffi.Pointer<ffi.Char> indices,
    int indices_len,
  ) {
    return _archived_indices(indices, indices_len);
  }

  late final _archived_indicesPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>, ffi.Size)
        >
      >('archived_indices');
  late final _archived_indices = _archived_indicesPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>, int)>();

  int get_index(
    ffi.Pointer<ffi.Void> archived_indices,
    ffi.Pointer<ffi.Void> index,
  ) {
    return _get_index(archived_indices, index);
  }

  late final _get_indexPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
        >
      >('get_index');
  late final _get_index = _get_indexPtr
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  void serialize_verses(
    ffi.Pointer<ffi.Void> painter,
    ffi.Pointer<ffi.Pointer<ffi.Char>> out,
    ffi.Pointer<ffi.Size> out_len,
  ) {
    return _serialize_verses(painter, out, out_len);
  }

  late final _serialize_versesPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Pointer<ffi.Char>>,
            ffi.Pointer<ffi.Size>,
          )
        >
      >('serialize_verses');
  late final _serialize_verses = _serialize_versesPtr
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
        )
      >();

  ffi.Pointer<ffi.Void> load_model(
    ffi.Pointer<ffi.Char> embeddings,
    int embeddings_len,
    ffi.Pointer<ffi.Char> verses,
    int verses_len,
    ffi.Pointer<ffi.Char> model,
    int model_len,
    ffi.Pointer<ffi.Char> tokenizer,
    int tokenizer_len,
  ) {
    return _load_model(
      embeddings,
      embeddings_len,
      verses,
      verses_len,
      model,
      model_len,
      tokenizer,
      tokenizer_len,
    );
  }

  late final _load_modelPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
            ffi.Pointer<ffi.Char>,
            ffi.Size,
            ffi.Pointer<ffi.Char>,
            ffi.Size,
            ffi.Pointer<ffi.Char>,
            ffi.Size,
            ffi.Pointer<ffi.Char>,
            ffi.Size,
          )
        >
      >('load_model');
  late final _load_model = _load_modelPtr
      .asFunction<
        ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>,
          int,
        )
      >();

  ffi.Pointer<ffi.Void> get_result(
    ffi.Pointer<ffi.Void> model,
    ffi.Pointer<ffi.Char> query,
    int query_len,
  ) {
    return _get_result(model, query, query_len);
  }

  late final _get_resultPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Char>,
            ffi.Size,
          )
        >
      >('get_result');
  late final _get_result = _get_resultPtr
      .asFunction<
        ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Char>,
          int,
        )
      >();
}

final class TextStyle extends ffi.Struct {
  external ffi.Pointer<ffi.Char> font_family;

  @ffi.Size()
  external int font_family_len;

  @ffi.Float()
  external double font_size;

  @ffi.Float()
  external double height;

  @ffi.Float()
  external double letter_spacing;

  @ffi.Float()
  external double word_spacing;
}

enum Style {
  VERSE(0),
  NORMAL(1),
  HEADER(2),
  CHAPTER(3);

  final int value;
  const Style(this.value);

  static Style fromValue(int value) => switch (value) {
    0 => VERSE,
    1 => NORMAL,
    2 => HEADER,
    3 => CHAPTER,
    _ => throw ArgumentError("Unknown value for Style: $value"),
  };
}

final class Rectangle extends ffi.Struct {
  @ffi.Float()
  external double top;

  @ffi.Float()
  external double left;

  @ffi.Float()
  external double width;

  @ffi.Float()
  external double height;
}

final class Text extends ffi.Struct {
  external ffi.Pointer<ffi.Char> text;

  @ffi.Size()
  external int len;

  external Rectangle rect;

  external TextStyle style;
}

final class Dimensions extends ffi.Struct {
  @ffi.Float()
  external double width;

  @ffi.Float()
  external double height;

  @ffi.Float()
  external double header_height;

  @ffi.Float()
  external double drop_cap_padding;
}
